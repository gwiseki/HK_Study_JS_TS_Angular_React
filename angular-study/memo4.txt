서비스 - 웹 앱이 견고한 앱으로 거듭나기 위해 필요. 컴포넌트에서 비즈니스 로직을 분리해 관리할 수 있음. 뷰와 관련없이 앱 전역에서 사용할 수 있는 순수한 비즈니스 로직이나 값을 다루는 클래스. 서비스가 없으면 여러 컴포넌트에서 반복 작성해야 하는 로직도 발생할 것. 서비스를 사용하면 모든 컴포넌트에서 기능을 수정할 필요 없이 하나의 서비스만 수정하면 된다. 컴포넌트에서 뷰와 연관이 없거나 여러 컴포넌트에 산재한 공통 로직을 분리해서 서비스에 담아야. 컴포넌트에 뷰의 로직과 비즈니스 로직이 공존하는 상황은 전형적인 안티패턴임. 

서비스는 cp와 달리 꼭 붙여야 하는 데코레이터는 없다. -> 순수한 ts 클래스. 다만 @injectable을 붙이는 것을 권장. 없어도 동작(필수는 아니다)

ng new mouse-pos-logger --prefix mpl
ng g service my-special-logger
ng g enum log-level

@input 데코레이터를 통해 상위 컴포넌트에서 전달한 데이터를 받을 수 있음. 그렇게 하면 컴포넌트 @input이 붙은 속성은 템플릿에서 프로퍼티 바인딩 시 속성으로 사용 가능. -> 싱글톤 방식으로 구현 가능 - 싱글턴 패턴은 인스턴스가 오직 1개만 생성되야 하는 경우에 사용되는 패턴입니다. 예를들어 레지스트리 같은 설정 파일의 경우 객체가 여러개 생성되면 설정 값이 변경될 위험이 생길 수 있습니다.
인스턴스 1개만 생성되는 특징을 가진 싱글턴 패턴을 이용하면, 하나의 인스턴스를 메모리에 등록해서 여러 컴포넌트가 동시에 해당 인스턴스를 공유하여 사용하게끔 할 수 있으므로, 요청이 많은 곳에서 사용하면 효율을 높일 수 있습니다.

ng의 의존성 주입기는 데코레이터 여부로 인스턴스를 생성할 때 생성자에 의해 의존성을 주입해 줄 필요가 있는지를 결정함.  서비스의 경우 평범한 ts 클래스이므로 생성자에 매개변수를 선언해두어도 ng의 의존성주입기가 의존성 주입이 필요한지를 확인할 방법이 없음. 그러므로 서비스에서 생성자의 매개 변수로 의존성 주입이 필요한 경우에는 클래스에 Injectable을 붙여야 함. 생성자의 매개변수로 주입받을 의존성 정보가 없다면 굳이 붙이지 않아도 되지만 관례상 코드의 확장을 위하여, 또는 버그를 미연에 방지하기 위하여 서비스를 선언할 때 Injectable을 붙이는 것을 권장하는 것.
constructor( @Inject(LOG_LEVEL_TOKEN) logLevel: LogLevel)  -> 생성자의 인자로 받는 logLevel앞에 @inject 붙이고('logLevel') 해줌.
그 다음 app.module.ts에 { provide: 'logLevel', useValue: LogLevel.INFO } 해줌. 이 JSON




